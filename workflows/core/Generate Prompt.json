{
  "name": "Generate Prompt",
  "nodes": [
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "promptTemplate"
            },
            {
              "name": "dataObject",
              "type": "object"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        0,
        0
      ],
      "id": "c89f01fe-286e-45ea-8ccf-c3fb01eab7fd",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code Node: Generate Prompt from Template (Enhanced with Type Detection)\n// Supports dot notation, object serialization, and date formatting\n\nconst items = $input.all();\nconst outputItems = [];\n\n// Helper to safely access nested properties using dot notation\nfunction getNestedValue(obj, path) {\n  if (!obj || !path) return null;\n  \n  // Handle array notation like \"operations[0].text\"\n  const arrayMatch = path.match(/^(.+?)\\[(\\d+)\\](.*)$/);\n  if (arrayMatch) {\n    const [, basePath, index, remainder] = arrayMatch;\n    const baseValue = getNestedValue(obj, basePath);\n    if (!Array.isArray(baseValue)) return null;\n    const arrayValue = baseValue[parseInt(index)];\n    return remainder ? getNestedValue(arrayValue, remainder.replace(/^\\./, '')) : arrayValue;\n  }\n  \n  // Standard dot notation\n  return path.split('.').reduce((current, prop) => {\n    return current && current[prop] !== undefined ? current[prop] : null;\n  }, obj);\n}\n\n// Corrected Date Formatting Function\nfunction formatDate(dateValue) {\n  // 1. Immediately reject plain numbers to prevent treating them as timestamps.\n  //    This fixes the bug where '500' becomes 'January 1, 1970 00:00'.\n  if (typeof dateValue === 'number') {\n    return null;\n  }\n\n  // 2. For strings, only attempt to parse those that resemble an ISO 8601 date.\n  //    This makes date detection more reliable and specific.\n  if (typeof dateValue === 'string') {\n    // A simple regex to check for a YYYY-MM-DDTHH:MM:SS pattern.\n    const isoLikeRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/;\n    if (!isoLikeRegex.test(dateValue.trim())) {\n      return null; // If it doesn't look like a date, don't format it.\n    }\n  }\n\n  let date;\n\n  // Now, try to create a Date object from a Date object or a valid string.\n  if (dateValue instanceof Date) {\n    date = dateValue;\n  } else if (typeof dateValue === 'string') {\n    date = new Date(dateValue);\n  } else {\n    // Ignore all other types (e.g., boolean, object)\n    return null;\n  }\n\n  // Final check to ensure the created date is valid.\n  if (!date || isNaN(date.getTime())) {\n    return null;\n  }\n\n  // --- Formatting logic (this part is unchanged) ---\n  const months = [\n    'January', 'February', 'March', 'April', 'May', 'June',\n    'July', 'August', 'September', 'October', 'November', 'December'\n  ];\n\n  const month = months[date.getMonth()];\n  const day = date.getDate();\n  const year = date.getFullYear();\n  const hours = String(date.getHours()).padStart(2, '0');\n  const minutes = String(date.getMinutes()).padStart(2, '0');\n\n  return `${month} ${day}, ${year} ${hours}:${minutes}`;\n}\n\n// Type-aware value formatting\nfunction formatValue(value) {\n  if (value === null || value === undefined) {\n    return 'N/A';\n  }\n  \n  // Check if it's a date (including date strings and timestamps)\n  const formattedDate = formatDate(value);\n  if (formattedDate) {\n    return formattedDate;\n  }\n  \n  // Handle different types\n  const valueType = typeof value;\n  \n  switch (valueType) {\n    case 'string':\n    case 'number':\n    case 'boolean':\n      return String(value).trim();\n    \n    case 'object':\n      if (Array.isArray(value)) {\n        // For arrays, try to create a readable list\n        if (value.length === 0) {\n          return 'N/A';\n        }\n        \n        // If array contains simple values, join them\n        const hasComplexItems = value.some(item => \n          typeof item === 'object' && item !== null && !Array.isArray(item)\n        );\n        \n        if (!hasComplexItems) {\n          return value.join(', ');\n        }\n        \n        // For complex arrays, use JSON\n        return JSON.stringify(value, null, 2);\n      } else {\n        // For objects, use formatted JSON\n        return JSON.stringify(value, null, 2);\n      }\n    \n    default:\n      return String(value);\n  }\n}\n\n// Convert various naming conventions\nfunction generateKeyVariations(key) {\n  // Clean the key first\n  const cleanKey = key.trim();\n  \n  // For dot notation, we want to try the exact path first\n  if (cleanKey.includes('.')) {\n    return [cleanKey];\n  }\n  \n  // For simple keys, try various formats\n  const words = cleanKey.split(/[\\s\\-_]+/).filter(word => word.length > 0);\n  if (words.length === 0) return [cleanKey];\n  \n  const variations = new Set([\n    cleanKey,                                    // Original: \"Podcast Name\"\n    cleanKey.toLowerCase(),                      // lowercase: \"podcast name\"\n    cleanKey.replace(/\\s+/g, ''),               // No spaces: \"PodcastName\"\n    cleanKey.replace(/\\s+/g, '_'),              // Underscore: \"Podcast_Name\"\n    cleanKey.replace(/\\s+/g, '_').toLowerCase(), // Snake case: \"podcast_name\"\n    words.join(''),                             // Concatenated: \"PodcastName\"\n    words.join('_'),                            // Underscore joined: \"Podcast_Name\"\n    words.join('_').toLowerCase(),              // Snake case: \"podcast_name\"\n    words.map(w => w.toLowerCase()).join('_'),   // Lower snake: \"podcast_name\"\n    \n    // CamelCase variations\n    words[0].toLowerCase() + words.slice(1).map(w => \n      w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()\n    ).join(''),                                  // camelCase: \"podcastName\"\n    \n    words.map(w => \n      w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()\n    ).join(''),                                  // PascalCase: \"PodcastName\"\n  ]);\n  \n  return Array.from(variations);\n}\n\n// Enhanced token replacement with type detection\nfunction replacePromptTokens(promptTemplate, dataObject) {\n  if (!promptTemplate) return '';\n  \n  let processedPrompt = promptTemplate;\n  const tokenPattern = /\\{\\{([^}]+)\\}\\}/g;\n  const tokens = [...promptTemplate.matchAll(tokenPattern)];\n  \n  tokens.forEach(([fullMatch, tokenName]) => {\n    const cleanToken = tokenName.trim();\n    let replacementValue = null;\n    \n    // First, try direct dot notation access\n    if (cleanToken.includes('.')) {\n      replacementValue = getNestedValue(dataObject, cleanToken);\n    }\n    \n    // If not found or not dot notation, try variations\n    if (replacementValue === null || replacementValue === undefined) {\n      const possibleKeys = generateKeyVariations(cleanToken);\n      \n      for (const key of possibleKeys) {\n        const value = getNestedValue(dataObject, key);\n        if (value !== null && value !== undefined) {\n          replacementValue = value;\n          break;\n        }\n      }\n    }\n    \n    // Format the replacement value with type awareness\n    const finalValue = formatValue(replacementValue);\n    \n    // Replace all instances of this token\n    processedPrompt = processedPrompt.replace(\n      new RegExp(fullMatch.replace(/[{}]/g, '\\\\$&'), 'g'), \n      finalValue\n    );\n  });\n  \n  return processedPrompt;\n}\n\n// Process each item\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  \n  try {\n    const promptTemplate = item.json.promptTemplate;\n    const dataObject = item.json.dataObject || item.json;\n    const configuration = item.json.configuration || {};\n    \n    if (!promptTemplate) {\n      throw new Error('No prompt template provided');\n    }\n    \n    const generatedPrompt = replacePromptTokens(promptTemplate, dataObject);\n    \n    // Extract all tokens from template for debugging\n    const tokenPattern = /\\{\\{([^}]+)\\}\\}/g;\n    const foundTokens = [...promptTemplate.matchAll(tokenPattern)].map(match => match[1].trim());\n    \n    // Check which tokens were successfully replaced with type info\n    const replacementStatus = {};\n    foundTokens.forEach(token => {\n      let value = token.includes('.') \n        ? getNestedValue(dataObject, token)\n        : null;\n      \n      if (value === null || value === undefined) {\n        const variations = generateKeyVariations(token);\n        for (const key of variations) {\n          const testValue = getNestedValue(dataObject, key);\n          if (testValue !== null && testValue !== undefined) {\n            value = testValue;\n            break;\n          }\n        }\n      }\n      \n      replacementStatus[token] = {\n        found: value !== null && value !== undefined,\n        type: value === null || value === undefined ? 'missing' : typeof value,\n        isDate: formatDate(value) !== null,\n        isArray: Array.isArray(value),\n        formattedValue: formatValue(value)\n      };\n    });\n    \n    outputItems.push({\n      json: {\n        generatedPrompt,\n        configuration,\n        originalTemplate: promptTemplate,\n        processedAt: new Date().toISOString(),\n        debug: {\n          foundTokens,\n          replacementStatus,\n          dataObjectKeys: Object.keys(dataObject || {})\n        }\n      },\n      pairedItem: i\n    });\n    \n  } catch (error) {\n    outputItems.push({\n      json: {\n        _error: {\n          type: 'prompt_generation_error',\n          message: error.message\n        },\n        originalTemplate: item.json.promptTemplate,\n        processedAt: new Date().toISOString()\n      },\n      pairedItem: i\n    });\n  }\n}\n\nconsole.log(`Processed ${outputItems.length} items for prompt generation`);\n\nreturn outputItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        0
      ],
      "id": "fc4d92ba-e216-4604-bfc6-0e460aa7a9bb",
      "name": "Generate"
    }
  ],
  "pinData": {},
  "connections": {
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Generate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "47df6c6b-dca1-434f-86f8-3bef60380de9",
  "meta": {
    "instanceId": "8edd5d7e3ae181bc95a0413e7506e4b6ee1385f7be5a93f8cbfb6d9b5a737e91"
  },
  "id": "vSI24g1hr0arhJtE",
  "tags": []
}